# Top-level module
DESIGN_NAME ?= wrapper

# Run directory for DesignCompiler
DC_RUN_DIR := $(SYN_PATH)/run_dc

.PHONY: deps.syn check_design.syn lookup.syn clean.syn

deps.syn:
	$(eval include $(TB_PATH)/$(TB)/Makefile.frag)
	$(eval LOG_DIR  := $(LOG_PATH)/dc)
	$(eval REPORT_DIR := $(REPORT_PATH)/dc)
	$(eval LOG_FILE := $(LOG_DIR)/$(TB)_check_design.log)
	$(eval ERR_FILE := $(LOG_DIR)/$(TB)_check_design.err)
	$(shell mkdir -p $(LOG_DIR))
	$(shell mkdir -p $(REPORT_DIR))
	$(shell mkdir -p $(DC_RUN_DIR))
	@grep -v -e "^\#" $(SYN_PATH)/flist.vcs > $(DC_RUN_DIR)/flist.vcs || true
	@echo '$(DC_RUN_DIR)/wrapper.v' >> $(DC_RUN_DIR)/flist.vcs || true
	@sed "s/BP_CFG_FLOWVAR/$(CFG)/g" $(TB_PATH)/$(TB)/wrapper.v > $(DC_RUN_DIR)/wrapper.v || true

# Check if the design is synthesizable. This is not an actual synthesis run,
# but rather runs analysis and elaboration on the design without linking any
# specific process. This is significantly quicker than running a full synthesis
# run and doesn't require any design constraints. Instead, this let's RTL
# designers catch issues with the design such as non-synthesizable code. The
# wildcard in the target.

check_design.syn: CALC_DEBUG=0
check_design.syn: TRACE_REPLAY=0
check_design.syn: deps.syn
	cd $(DC_RUN_DIR); \
	$(DC_SHELL) -64bit -f $(BP_COMMON_DIR)/syn/tcl/dc_elab.tcl | tee -i $(LOG_FILE)
	@grep --color      "^Error"                               $(LOG_FILE) | tee -a $(ERR_FILE) || true
	@grep --color      "Complex logic will not be considered" $(LOG_FILE) | tee -a $(ERR_FILE) || true
	@grep --color -B 3 "*** Presto compilation terminated"    $(LOG_FILE) | tee -a $(ERR_FILE) || true
	@grep --color      "unresolved references."               $(LOG_FILE) | tee -a $(ERR_FILE) || true
	@grep --color      "Cannot find the design"               $(LOG_FILE) | tee -a $(ERR_FILE) || true
	@grep --color      "undeclared symbol"                    $(LOG_FILE) | tee -a $(ERR_FILE) || true
	@grep --color      "latch in always_comb"                 $(LOG_FILE) | tee -a $(ERR_FILE) || true
	if [[ -s $(ERR_FILE) ]]; then \
		echo "Design Compiler check_synth: FAILED" | tee $(REPORT_DIR)/$(TB)_check_synth.rpt; \
		cp $(ERR_FILE) $(REPORT_DIR)/$(TB)_check_synth_err.rpt; \
	else \
		echo "Design Compiler check_synth: PASSED" | tee $(REPORT_DIR)/$(TB)_check_synth.rpt; \
	fi;

# This target allows users to look up commands and message codes for
# DesignCompiler. If there is a message with a code (e.g. LINT-1) then you can
# replace the wildcard with the code (e.g. make LINT-1.lookup.syn) to query
# DesignCompiler for a detailed explaination of the message code. You can also
# use this for DesignCompiler commands and application variables.

lookup.syn:
	$(DC_SHELL) -64bit -x "set_app_var sh_command_log_file /dev/null; man $*; exit"

# Cleanup all files generated by DesignCompiler

clean.syn:
	rm -rf $(DC_RUN_DIR)

