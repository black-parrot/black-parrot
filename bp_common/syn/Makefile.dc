override TOOL := dc

override LOG_DIR     := $(LOG_PATH)/$(TOOL)
override RESULTS_DIR := $(RESULTS_PATH)/$(TOOL)
override REPORT_DIR  := $(REPORT_PATH)/$(TOOL)
override TOUCH_DIR   := $(TOUCH_PATH)/$(TOOL)

BUILD_DIR := $(RESULTS_DIR)/$(TB).$(CFG).$(TAG).build
$(TOUCH_DIR) $(RESULTS_DIR) $(LOG_DIR) $(REPORT_DIR) $(BUILD_DIR):
	mkdir -p $@

.PHONY: check_design.syn lookup.syn clean.syn

include $(TB_PATH)/$(TB)/Makefile.dc

# Check if the design is synthesizable. This is not an actual synthesis run,
# but rather runs analysis and elaboration on the design without linking any
# specific process. This is significantly quicker than running a full synthesis
# run and doesn't require any design constraints. Instead, this let's RTL
# designers catch issues with the design such as non-synthesizable code. The
# wildcard in the target.

check_design.syn: $(BUILD_DIR)/check
check_design.syn: CHK_LOG    := $(LOG_DIR)/$(TB).$(CFG).$(TAG).check_design.log
check_design.syn: CHK_REPORT := $(REPORT_DIR)/$(TB).$(CFG).$(TAG).check_design.rpt
check_design.syn: CHK_ERROR  := $(REPORT_DIR)/$(TB).$(CFG).$(TAG).check_design.err
check_design.syn: DESIGN_NAME ?= wrapper
# Change to your own stdcell db from a PDK. We suggest the freely available FreePDK45
$(CHK_COLLATERAL): | $(TOUCH_DIR) $(RESULTS_DIR) $(LOG_DIR) $(REPORT_DIR) $(BUILD_DIR)
$(BUILD_DIR)/check: $(CHK_COLLATERAL)
	$(eval export DESIGN_NAME)
	$(eval export STDCELL_DB)
	cd $(@D); \
		$(DC_SHELL) -64bit -f $(BP_COMMON_DIR)/syn/tcl/dc_elab.tcl 2>&1 | tee -i $(CHK_LOG)
		-@grep --color      "^Error"                               $(CHK_LOG) 2>&1 | tee    $(CHK_ERROR)
		-@grep --color      "Complex logic will not be considered" $(CHK_LOG) 2>&1 | tee -a $(CHK_ERROR)
		-@grep --color -B 3 "*** Presto compilation terminated"    $(CHK_LOG) 2>&1 | tee -a $(CHK_ERROR)
		-@grep --color      "unresolved references."               $(CHK_LOG) 2>&1 | tee -a $(CHK_ERROR)
		-@grep --color      "Cannot find the design"               $(CHK_LOG) 2>&1 | tee -a $(CHK_ERROR)
		-@grep --color      "undeclared symbol"                    $(CHK_LOG) 2>&1 | tee -a $(CHK_ERROR)
		-@grep --color      "(ELAB-395)"                           $(CHK_LOG) 2>&1 | tee -a $(CHK_ERROR)
		-@grep --color      "(OPT-150)"                            $(CHK_LOG) 2>&1 | tee -a $(CHK_ERROR)
		-@grep --color      "declaration initial"                  $(CHK_LOG) 2>&1 | tee -a $(CHK_ERROR)
		-@test -s $(CHK_ERROR) && echo "Design Compiler check_synth: FAILED" > $(CHK_REPORT) \
		|| (echo "Design Compiler check_synth: PASSED" > $(CHK_REPORT) && rm $(CHK_ERROR))

# Does the check_design target, but also checks for timing loops
# We accomplish this by overriding the STDCELL_DB variable
check_loops.syn: STDCELL_DB ?= $(FREE45_NLDM_DB_TYP)
check_loops.syn: check_design.syn

# This target allows users to look up commands and message codes for
# DesignCompiler. If there is a message with a code (e.g. LINT-1) then you can
# replace the wildcard with the code (e.g. make LINT-1.lookup.syn) to query
# DesignCompiler for a detailed explaination of the message code. You can also
# use this for DesignCompiler commands and application variables.

lookup.syn:
	$(DC_SHELL) -64bit -x "set_app_var sh_command_log_file /dev/null; man $*; exit"

# Cleanup all files generated by DesignCompiler

clean.syn:
	@-rm -rf results/dc
	@-rm -rf reports/dc
	@-rm -rf logs/dc

