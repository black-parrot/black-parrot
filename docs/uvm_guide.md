# UVM GUIDE For Black Parrot
## Current Extent of UVM Support
  Currently UVM is only supported for the BP L1 I-cache found in /bp_fe/src/v/bp_fe_icache.sv with a UCE connected.

## How to Simulate Existing Testbenches:
* Navigate to /bp_fe/syn/
* Base command: `make run_testlist.v UCE_P=1 TB=uvm`
  * Note: At this time the UVM testbench only supports VCS.
* Options:
  * UVM_VERBOSITY = UVM_NONE to UVM_FULL
    * Sets the verbosity of UVM messages for the simulation using the plusarg of the same name.
  * Waveform dumping
    * To dump waves for a specific test replace `run_testlist.v` with `build_dump.v sim.v PROG=test_load TAG=UCE` where test_load is the name of the test.
    * Otherwise, you can replace build in Makefile.testlist with build_dump temporarily to dump waves for all tests.
  * Coverage information
    * To get coverage using URG, add the `cov.v` keyword after `run_testlist.v`

## Work that needs to be done to extend UVM Testbenches:

As discussed above currently only the I-cache has UVM support, and other modules could use UVM testbenches of their own.  The simplest to implement on top of the existing one is the D-Cache, but there are more possible choices.

### I-Cache
- A functional model of the cache used by the predictor could be created (whether in System Verilog or with another language through the System Verilog DPI).
- Coverage groups could be greatly improved to better reflect the cache behavior and testing goals.
- Many more tests could be added to verify all aspects of the cache's functionality.
- Support for the LCE in addition to the UCE currently implemented would also be a great improvement.

## Explanation of I-Cache Testbench Design:

### UVM Background:
If you are new to the Universal Verification Methodology(UVM), then you should first spend some time learning the general concepts.  A few recommended resources are listed below:
* https://verificationacademy.com/cookbook/uvm
* https://verificationacademy.com/courses/uvm-basics
* https://verificationacademy.com/courses/advanced-uvm
* https://ieeexplore.ieee.org/document/9195920

### Testbench Overview:
![uvm_arch.svg](uvm_arch.svg)

The top-level module [testbench.sv](../bp_fe/test/tb/uvm/testbench.sv) contains an instance of the I$, the UCE, and non-synthesizable DRAM.  The non-synthesizable DRAM loads the data written in the file prog.mem which is generated by the environment to the simulation directory.
There are four interfaces, the data input, the data output, the TLB, and the Cace Engine (UCE).  These are all defined in [icache_uvm_if.sv](../bp_fe/test/tb/uvm/icache_uvm_if.sv).  The reason that four separate interfaces are used is to be able to drive and monitor each interface independent from the other (as will be discussed further when talking about virtual sequences below).

### Testbench Components
#### Enviornment
Located at [icache_uvm_cfg.sv](../bp_fe/test/tb/uvm/icache_uvm_cfg.sv), the configuration information for the environment (and agents) are passed using configuration objects.  For the environment, the configuration object (which is set by each test) passes handles to each of the four interfaces and a boolean for each interface to indicate whether that interface's agent is active or passive.  This information is then passed to each agent (there is one for each interface) by creating agent configuration objects and setting the activity of the agent. In the context of UVM, an active agent has a sequencer and a driver, whereas a passive agent does not (there will be a monitor regardless).  

#### Agents
The agent contains the monitor and depending on the activity level also the sequencer and driver, which for the sake of discussing connections we will assume are instantiated.  Within the agent, the sequencer is connected to the driver and sends transactions for the driver to drive depending on the sequence defined in the test.  The monitor is also connected to the analysis port that each agent posses, which broadcasts to the subscribers.

#### Monitors
The monitor is intended at every positive clock edge to make a transaction from the values of the wires on the interface at that given point in time and send them to the subscribers.
* There is one monitor per interface in the design.
* The run phase consists of the following steps:
  * Waits for reset to go low initially.
  * At each positive clock edge:
  1. Package interface pins as a transaction.
  2. Send transaction over analysis port to subscribers (described below).

#### Drivers
At 'every' clock edge the driver takes transactions from the sequencer and drives the wires on a given interface with the values in the transaction.
* There is one driver per interface in the design.
* The run phase for the input driver consists of the following steps:
  * Waits for reset to go low initially.
  * The following code loops:
  1. Get a transaction from the sequencer (wait until one is sent).
  2. Wait until we are at a positive clock edge
  3. Drive transactions at a pin-level on the interface.
  4. If we sent a transaction with v_i set across the interface, wait for the ready_o signal to be set by the cache.
  5. Send a message to the sequencer indicating that we have completed the transaction.
* The run phase for the TLB driver is the same with two exceptions.  First, it does not wait for the ready_o signal to be set, as that is not present on the TLB interface.  Second, it adds the transactions received from the sequencer into a queue of length one, achieving the effect of delaying the transaction from the sequencer by 1 cycle.  This is desired because the cache wants the physical tag for a given input transaction a cycle after that input transaction, so if we are driving our TLB and input in parallel in a virtual sequence as discussed below, we can define the input and tlb transactions at the same time.

### Analysis Components
#### Coverage Collector
The coverage collector is used to collect functional coverage information so that one can better know what they need to write tests for, or conversely, what they have already tested.  This coverage collector needs to asynchronously handle coverage information for all four interfaces of the DUT.  Therefore, we use a UVM construct called analysis imps to define an analysis port for each interface's monitor to broadcast to.  Then, every time that the coverage collector sees a transaction on its analysis port, it will sample coverage information for that interface with the given transaction.  The coverage information is defined in coverage groups in the coverage collector, with specific bins defined where necessary.  Coverage groups, coverage points, and bins are all part of the SystemVerilog standard, so look to the IEEE specification for more information.

#### Scoreboard
In the UVM the scoreboard is used to compare the output of the DUT against some emulated/functional model of the DUT to verify that the output is what is expected.  Herein, our scoreboard has three analysis ports that receive transactions from the input monitor, the tlb monitor, and the output monitor.  These three ports are implemented as analysis imps so that when each receives a transaction, it handles it accordingly.  The input and tlb transactions are sent to the predictor as they are received.  In addition, the input transaction is queued in a 2 item long queue, such that the cache request lines up with the cache response from the output monitor.  When a transaction comes in on the output port, we first pop an item from the input queue so that it remains 2 items long.  Then check if the transaction is valid and if it is we assign an id to the transaction (used by the comparator) which is the virtual address of the input transaction.  Then we send that output transaction to the comparator.

#### Predictor
In the UVM the predictor is a functional model of the cache which should give the same output as the actual cache for the sake of comparison.  In its current state, the predictor written here is not a complex functional model, but instead is hardcoded to be accurate for the test_load and test_uncached_load tests.  This is a place for future work, which we greatly encourage someone to come along and complete.  Currently, the predictor takes the input and tlb transaction from its input and if they are valid, gives an output that is valid and indexed according to the input transaction virtual address.  This output is broadcast to the comparator to be compared to the output from the scoreboard (and inherently, the DUT).

#### Comparator
In the UVM the comparator compares and reports on the comparison between the predicted and actual output.  Since we are using a ready valid protocol here, there is not a guaranteed time that the predicted output should arrive such that it coincides with the time that the actual output arrives.  Therefore, we need to build a comparator that is out of order using an associative array.  A nice guide for this is found in the UVM Cookbook linked above.  The comparator works as follows:
* The comparator implements an analysis fifo for both the DUT and predicted transactions.
* In the run phase the get_data function is forked for both the DUT and the predictor
  * This function implements two arrays, the first is an array where each index is a queue containing a transaction that has been received for a given index, and the second is an array that counts the predictor and dut transactions with an int.  Both arrays are indexed by the transaction id's set in both the scoreboard and the predictor for the given transaction.
  * When a transaction is received, it checks to see if a transaction has been received previously for this virtual address from the other analysis port
    * If so the two transactions which matched are compared and whether there is a match or mismatch is recorded.  At this point, we can deallocate the queue from the array of queues, and the count from the array of counts.
    * If not, the transaction is added to the queue corresponding to its index in the array of queues.  Then the count is updated for a given index, incrementing if the transaction came in on the predictor fifo and decrementing if the transaction came in on the DUT fifo.
* The report phase then prints how many Matches, Mismatches, and Missing transactions were recorded in the comparator.

### Tests and Sequences
#### Transactions
There are four interfaces, so it follows that there will be four different types of transactions to be driven on each interface.  These transactions contain the bits that we use to define them on each interface as well as helper functions for handling the transactions.  In all of the transaction classes, the do_copy() and convert2string() functions are defined for all interfaces.  In addition, the output interface defines the do_compare() function to be used in the comparator of the scoreboard analysis component, defining how we determine if two output transactions are equal.

##### Tests
In the UVM infrastructure, the test can define configuration information for a given run of the testbench and the sequences that will stimulate that DUT.  As is common practice, we have defined a base test that extends from uvm_test, so that the standard testbench configuration not changed by each test is encapsulated.  Then we extend from that base_test for each subsequent test that we wish to make.  Currently, there is a test_load test and a test_uncached_load test both of which extend from base_test, and are modeled after the existing tests which use the trace replay environment.  Each of these tests overrides the type of the virtual sequence in the base test so that the test creates and calls a specific virtual sequence that is defined in the sequence package.

##### Virtual Sequences
A virtual sequence in UVM is used to drive two or more interfaces simultaneously with different sequences.  In our case, we need to drive both the input interface and the TLB interface.  The base virtual sequence extends from uvm_sequence_item and defines handles to four interfaces of each type, which are defined by the base test to 'point' to the proper pins on the DUT.  Then each virtual sequence extending from that implements the test. 

The test_uncached_load virtual sequence sends an uncached fill request for address 0x24, then sends a couple of blank cycles on both the input and TLB interface, then sends another uncached fill request of address 0x24.  The first fill request will cause the cache to fill in the correct data.  Then the second fill request will only actually occur once the I$ signals that it is ready at which point it will have filled the data and can output it.

The test_load virtual sequence sends a cached fill request first for addresses 0x00, 0x04, and 0x08.  Then sends a couple of blank cycles on both the input and TLB interface before sending a fill request for addresses 0x00-0x3c.  It will receive the data for all of these addresses after the second series of fill requests.

##### Creating a New Test:
For this example we will create a new test called test_tlb_miss, where we simulate the cache output if we send a fill request, but it misses in the TLB.
1. Edit Makefile.testlist to include the new testname
```
  ICACHE_TESTLIST := \
     test_uncached_load \
     test_load \
     test_tlb_miss  # new test
```
2. In icache_uvm_tests_pkg add a new test extended from the base_test which calls the test_tlb_miss_vseq that we will define in the next step.  In addition, if you wished to change whether the input, tlb, output, or ce is active then in the build_phase one could add the line `tlb_is_active = 1'b0` to simulate without the tlb sequencer and driver which by default are enabled.
```
  class test_tlb_miss extends base_test;
    `uvm_component_utils(test_tlb_miss)

    function new(string name, uvm_component parent);
      super.new(name, parent);
    endfunction : new

    function void build_phase(uvm_phase phase);
      super.build_phase(phase);
      myvseq_base::type_id::set_type_override(test_tlb_miss_vseq::get_type());
    endfunction : build_phase
  endclass : test_tlb_miss
```
3. In icache_uvm_seq_pkg add a new virtual sequence for your test.  Here you have some flexibility as to whether to extend this from the base virtual sequence or one of the existing tests or otherwise.  In addition, you may be required to add a new sequence, or create hierarchical sequences to randomize.  If you do choose to add a new sequence, double check that the same functonality could not be achive using an existing sequence so as to keep the file from being unneccessarily large.  In our case we choose to add a new sequence extended from the base which requests a single adddress of data, but provides
```
class test_tlb_miss_vseq extends myvseq_base;
  `uvm_object_utils(test_tlb_miss_vseq);

  function new (string name = "test_tlb_miss_vseq");
    super.new(name);
  endfunction: new

  task body();
    fill_sequence test_seq = fill_sequence::type_id::create("test_seq");
    zero_sequence z_seq = zero_sequence::type_id::create("z_seq");
    ptag_sequence ptag_seq = ptag_sequence::type_id::create("ptag_seq");
    tlb_zero_sequence tz_seq = tlb_zero_sequence::type_id::create("tz_seq");

    test_seq.seq_pkt.vaddr = (1'b1 << 'd31) | 'h24;
    ptag_seq.ptag_i = 28'h0080000;

    `uvm_info("test_tlb_miss_vseq", "starting sequence", UVM_HIGH);

    // Ask for fill from 0x24 with TLB miss
    fork
      repeat(2) test_seq.start(input_sequencer_h, this);
      repeat(2) tz_seq.start(tlb_sequencer_h, this);
    join

    // Do nothing for 2 cycles
    fork
      z_seq.start(input_sequencer_h, this);
      tz_seq.start(tlb_sequencer_h, this);
    join

    // Ask for fill from 0x24 again, TLB hit
    fork
      repeat(2) test_seq.start(input_sequencer_h, this);
      repeat(2) ptag_seq.start(tlb_sequencer_h, this);
    join

    // Do nothing after that
    fork
      z_seq.start(input_sequencer_h, this);
      tz_seq.start(tlb_sequencer_h, this);
    join

    `uvm_info("test_uncached_load_vseq", "sequence finished", UVM_HIGH);
  endtask : body

endclass : test_tlb_miss_vseq
```
